//! # MM-Gateway Types
//!
//! Core type definitions matching the CLOB interface for order submission and execution.

use serde::{Deserialize, Serialize};

/// Order side enum matching Solidity
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Side {
    BUY = 0,
    SELL = 1,
}

impl Side {
    /// Convert to string for CLOB API
    pub fn as_str(&self) -> &'static str {
        match self {
            Side::BUY => "BUY",
            Side::SELL => "SELL",
        }
    }
}

/// Signature type enum matching Solidity
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[repr(u8)]
pub enum SignatureType {
    EOA = 0,
    PolyProxy = 1,
    PolyGnosisSafe = 2,
    Poly1271 = 3,
}

/// Order request payload for CLOB submission
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderRequest {
    /// Maker address
    pub maker: String,
    /// Token ID (as string to handle large numbers)
    pub token_id: String,
    /// Order side: BUY or SELL
    pub side: String,
    /// Price per token (6 decimal places, as string)
    pub price: String,
    /// Quantity (6 decimal places, as string)
    pub quantity: String,
    /// Order hash from EIP-712 signature
    pub order_hash: String,

    // Polymarket Signed Order Fields (required for on-chain execution)
    pub salt: String,
    pub signer: String,
    pub taker: String,
    pub maker_amount: String,
    pub taker_amount: String,
    pub expiration: String,
    pub nonce: String,
    pub fee_rate_bps: String,
    pub signature_type: u8,
    pub signature: String,
}

/// Response from CLOB order submission
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderResponse {
    pub success: bool,
    pub order_id: Option<String>,
    pub trades: Vec<TradeResult>,
    pub error: Option<String>,
}

/// Trade execution result from CLOB
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeResult {
    pub trade_id: String,
    pub buyer: String,
    pub seller: String,
    pub token_id: String,
    pub price: String,
    pub quantity: String,
    pub taker_order_hash: String,
    pub maker_order_hashes: Vec<String>,
    pub maker_fill_amounts: Vec<String>,
}

/// Order book state snapshot
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderBookState {
    pub token_id: String,
    pub bids: Vec<PriceLevel>,
    pub asks: Vec<PriceLevel>,
}

/// Price level in the order book
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PriceLevel {
    pub price: String,
    pub quantity: String,
    pub order_count: u32,
}

/// Cancel order request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelRequest {
    pub order_hash: String,
    pub token_id: String,
}

/// Cancel order response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CancelResponse {
    pub success: bool,
    pub message: String,
}

/// Recent trades query response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradesResponse {
    pub trades: Vec<TradeResult>,
    pub count: usize,
}

use std::collections::HashMap;

/// MM inventory state
#[derive(Debug, Clone, Default)]
pub struct Inventory {
    /// Available USDC balance (scaled 1e6)
    pub usdc_balance: u64,
    /// Token balances indexed by Token ID (scaled 1e6)
    pub token_balances: HashMap<String, u64>,
    /// USDC reserved for open buy orders
    pub usdc_reserved: u64,
    /// Tokens reserved for open sell orders indexed by Token ID (scaled 1e6)
    pub token_reserved: HashMap<String, u64>,
    /// Pending BUY tokens (from open orders) indexed by Token ID
    pub pending_buy_tokens: HashMap<String, u64>,
}

impl Inventory {
    /// Available USDC for new buy orders
    pub fn available_usdc(&self) -> u64 {
        self.usdc_balance.saturating_sub(self.usdc_reserved)
    }

    /// Available token amount for sell orders
    pub fn available_token(&self, token_id: &str) -> u64 {
        let balance = self.token_balances.get(token_id).cloned().unwrap_or(0);
        let reserved = self.token_reserved.get(token_id).cloned().unwrap_or(0);
        balance.saturating_sub(reserved)
    }

    /// Total exposure (Current Balance + Pending Buys)
    pub fn total_exposure(&self, token_id: &str) -> u64 {
        let balance = self.token_balances.get(token_id).cloned().unwrap_or(0);
        let pending = self.pending_buy_tokens.get(token_id).cloned().unwrap_or(0);
        balance.saturating_add(pending)
    }
}

/// Quote generated by the quote engine
#[derive(Debug, Clone)]
pub struct Quote {
    pub side: Side,
    pub token_id: String,
    pub price: u64,    // Scaled 1e6
    pub quantity: u64, // Scaled 1e6
}

/// Open order tracked by MM
#[derive(Debug, Clone)]
pub struct OpenOrder {
    pub order_hash: String,
    pub token_id: String,
    pub side: Side,
    pub price: u64,
    pub quantity: u64,
    pub filled: u64,
    pub timestamp: u64,
}
